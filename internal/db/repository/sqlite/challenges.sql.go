// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.22.0
// source: challenges.sql

package sqlite

import (
	"context"
)

const createChallenge = `-- name: CreateChallenge :one
INSERT INTO challenges (
    name, rules
) VALUES ( ?, ?)
RETURNING id, name, rules
`

type CreateChallengeParams struct {
	Name  string `json:"name"`
	Rules string `json:"rules"`
}

func (q *Queries) CreateChallenge(ctx context.Context, arg CreateChallengeParams) (Challenge, error) {
	row := q.db.QueryRowContext(ctx, createChallenge, arg.Name, arg.Rules)
	var i Challenge
	err := row.Scan(&i.ID, &i.Name, &i.Rules)
	return i, err
}

const getChallenge = `-- name: GetChallenge :one
SELECT
    id, name, rules
FROM challenges
WHERE id = ?
`

func (q *Queries) GetChallenge(ctx context.Context, id int64) (Challenge, error) {
	row := q.db.QueryRowContext(ctx, getChallenge, id)
	var i Challenge
	err := row.Scan(&i.ID, &i.Name, &i.Rules)
	return i, err
}

const listChallenge = `-- name: ListChallenge :many
SELECT id, name, rules FROM challenges
`

func (q *Queries) ListChallenge(ctx context.Context) ([]Challenge, error) {
	rows, err := q.db.QueryContext(ctx, listChallenge)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Challenge{}
	for rows.Next() {
		var i Challenge
		if err := rows.Scan(&i.ID, &i.Name, &i.Rules); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateChallenge = `-- name: UpdateChallenge :one
UPDATE challenges
 SET name = ?, rules = ?
WHERE id = ?
RETURNING id, name, rules
`

type UpdateChallengeParams struct {
	Name  string `json:"name"`
	Rules string `json:"rules"`
	ID    int64  `json:"id"`
}

func (q *Queries) UpdateChallenge(ctx context.Context, arg UpdateChallengeParams) (Challenge, error) {
	row := q.db.QueryRowContext(ctx, updateChallenge, arg.Name, arg.Rules, arg.ID)
	var i Challenge
	err := row.Scan(&i.ID, &i.Name, &i.Rules)
	return i, err
}
