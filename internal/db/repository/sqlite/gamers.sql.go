// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.22.0
// source: gamers.sql

package sqlite

import (
	"context"
)

const createGamer = `-- name: CreateGamer :one
INSERT OR REPLACE INTO gamers (
    challenge_id, user_id, start_date, end_date, target
) VALUES ( ?, ?, ?, ?, ?)
    RETURNING challenge_id, user_id, start_date, end_date, target
`

type CreateGamerParams struct {
	ChallengeID int64 `json:"challenge_id"`
	UserID      int64 `json:"user_id"`
	StartDate   int64 `json:"start_date"`
	EndDate     int64 `json:"end_date"`
	Target      int64 `json:"target"`
}

func (q *Queries) CreateGamer(ctx context.Context, arg CreateGamerParams) (Gamer, error) {
	row := q.db.QueryRowContext(ctx, createGamer,
		arg.ChallengeID,
		arg.UserID,
		arg.StartDate,
		arg.EndDate,
		arg.Target,
	)
	var i Gamer
	err := row.Scan(
		&i.ChallengeID,
		&i.UserID,
		&i.StartDate,
		&i.EndDate,
		&i.Target,
	)
	return i, err
}

const deleteGamer = `-- name: DeleteGamer :exec
DELETE FROM gamers
WHERE user_id = ? and challenge_id  = ?
`

type DeleteGamerParams struct {
	UserID      int64 `json:"user_id"`
	ChallengeID int64 `json:"challenge_id"`
}

func (q *Queries) DeleteGamer(ctx context.Context, arg DeleteGamerParams) error {
	_, err := q.db.ExecContext(ctx, deleteGamer, arg.UserID, arg.ChallengeID)
	return err
}

const getLongestActivityPerDay = `-- name: GetLongestActivityPerDay :many
WITH max_distance_activities AS (
    SELECT
        a.user_id,
        strftime('%Y-%m-%d', datetime(a.start_date_local, 'unixepoch')) AS date,
        MAX(a.distance) AS max_distance
    FROM raw_activities AS a
             INNER JOIN gamers AS g ON a.user_id = g.user_id AND g.challenge_id = ?
    WHERE a.start_date_local BETWEEN g.start_date AND g.end_date
    GROUP BY a.user_id, date
)
SELECT a.id, a.user_id, a.create_at, a.start_date, a.start_date_local, a.distance, a.average_speed, a.moving_time, a.name, a.sport_type, a.max_speed, a.original_data
FROM raw_activities AS a
 INNER JOIN max_distance_activities AS mda ON a.user_id = mda.user_id AND a.distance = mda.max_distance
`

func (q *Queries) GetLongestActivityPerDay(ctx context.Context, challengeID int64) ([]RawActivity, error) {
	rows, err := q.db.QueryContext(ctx, getLongestActivityPerDay, challengeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []RawActivity{}
	for rows.Next() {
		var i RawActivity
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.CreateAt,
			&i.StartDate,
			&i.StartDateLocal,
			&i.Distance,
			&i.AverageSpeed,
			&i.MovingTime,
			&i.Name,
			&i.SportType,
			&i.MaxSpeed,
			&i.OriginalData,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLongestActivityPerDay2 = `-- name: GetLongestActivityPerDay2 :many
WITH max_distance_activities AS (
SELECT
    a.user_id,
    strftime('%Y-%m-%d', datetime(a.start_date_local, 'unixepoch')) AS date,
    MAX(a.distance) AS max_distance
FROM raw_activities AS a
    INNER JOIN register_users AS g ON a.user_id = g.id
WHERE a.start_date_local >= ?1 AND a.start_date_local <= ?2 AND a.sport_type='Run'
GROUP BY a.user_id, date
)
SELECT mda.date,
       a.id as activity_id,
       a.start_date_local,
       a.distance,
       a.average_speed,
       CAST((1000 / a.average_speed) / 60 AS REAL) AS pace,
       a.moving_time,
       a.name as activity_title,
       a.max_speed,
       g.first_name,
       g.last_name,
       g.user_name,
       g.profile,
       g.profile_medium
FROM raw_activities AS a
 INNER JOIN max_distance_activities AS mda ON a.user_id = mda.user_id AND a.distance = mda.max_distance
 INNER JOIN register_users AS g ON a.user_id = g.id
ORDER BY mda.date
`

type GetLongestActivityPerDay2Params struct {
	Begin int64 `json:"begin"`
	End   int64 `json:"end"`
}

type GetLongestActivityPerDay2Row struct {
	Date           interface{} `json:"date"`
	ActivityID     int64       `json:"activity_id"`
	StartDateLocal int64       `json:"start_date_local"`
	Distance       float64     `json:"distance"`
	AverageSpeed   float64     `json:"average_speed"`
	Pace           float64     `json:"pace"`
	MovingTime     int64       `json:"moving_time"`
	ActivityTitle  string      `json:"activity_title"`
	MaxSpeed       float64     `json:"max_speed"`
	FirstName      string      `json:"first_name"`
	LastName       string      `json:"last_name"`
	UserName       string      `json:"user_name"`
	Profile        string      `json:"profile"`
	ProfileMedium  string      `json:"profile_medium"`
}

func (q *Queries) GetLongestActivityPerDay2(ctx context.Context, arg GetLongestActivityPerDay2Params) ([]GetLongestActivityPerDay2Row, error) {
	rows, err := q.db.QueryContext(ctx, getLongestActivityPerDay2, arg.Begin, arg.End)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetLongestActivityPerDay2Row{}
	for rows.Next() {
		var i GetLongestActivityPerDay2Row
		if err := rows.Scan(
			&i.Date,
			&i.ActivityID,
			&i.StartDateLocal,
			&i.Distance,
			&i.AverageSpeed,
			&i.Pace,
			&i.MovingTime,
			&i.ActivityTitle,
			&i.MaxSpeed,
			&i.FirstName,
			&i.LastName,
			&i.UserName,
			&i.Profile,
			&i.ProfileMedium,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listGamers = `-- name: ListGamers :many
SELECT
    challenge_id, user_id, name as challenge_name, user_name, start_date, end_date, target
FROM gamers AS l
JOIN register_users AS r ON l.user_id = r.id AND active = 1
JOIN challenges AS c ON l.challenge_id = c.id
WHERE challenge_id = ?
`

type ListGamersRow struct {
	ChallengeID   int64  `json:"challenge_id"`
	UserID        int64  `json:"user_id"`
	ChallengeName string `json:"challenge_name"`
	UserName      string `json:"user_name"`
	StartDate     int64  `json:"start_date"`
	EndDate       int64  `json:"end_date"`
	Target        int64  `json:"target"`
}

func (q *Queries) ListGamers(ctx context.Context, challengeID int64) ([]ListGamersRow, error) {
	rows, err := q.db.QueryContext(ctx, listGamers, challengeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListGamersRow{}
	for rows.Next() {
		var i ListGamersRow
		if err := rows.Scan(
			&i.ChallengeID,
			&i.UserID,
			&i.ChallengeName,
			&i.UserName,
			&i.StartDate,
			&i.EndDate,
			&i.Target,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
