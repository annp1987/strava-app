// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.22.0
// source: gamers.sql

package sqlite

import (
	"context"
)

const createGamer = `-- name: CreateGamer :one
INSERT OR REPLACE INTO gamers (
    challenge_id, user_id, start_date, end_date, target
) VALUES ( ?, ?, ?, ?, ?)
    RETURNING challenge_id, user_id, start_date, end_date, target
`

type CreateGamerParams struct {
	ChallengeID int64 `json:"challenge_id"`
	UserID      int64 `json:"user_id"`
	StartDate   int64 `json:"start_date"`
	EndDate     int64 `json:"end_date"`
	Target      int64 `json:"target"`
}

func (q *Queries) CreateGamer(ctx context.Context, arg CreateGamerParams) (Gamer, error) {
	row := q.db.QueryRowContext(ctx, createGamer,
		arg.ChallengeID,
		arg.UserID,
		arg.StartDate,
		arg.EndDate,
		arg.Target,
	)
	var i Gamer
	err := row.Scan(
		&i.ChallengeID,
		&i.UserID,
		&i.StartDate,
		&i.EndDate,
		&i.Target,
	)
	return i, err
}

const deleteGamer = `-- name: DeleteGamer :exec
DELETE FROM gamers
WHERE user_id = ? and challenge_id  = ?
`

type DeleteGamerParams struct {
	UserID      int64 `json:"user_id"`
	ChallengeID int64 `json:"challenge_id"`
}

func (q *Queries) DeleteGamer(ctx context.Context, arg DeleteGamerParams) error {
	_, err := q.db.ExecContext(ctx, deleteGamer, arg.UserID, arg.ChallengeID)
	return err
}

const getLongestActivityPerDay = `-- name: GetLongestActivityPerDay :many
WITH max_distance_activities AS (
    SELECT
        a.user_id,
        strftime('%Y-%m-%d', datetime(a.start_date_local, 'unixepoch')) AS date,
        MAX(a.distance) AS max_distance
    FROM raw_activities AS a
             INNER JOIN gamers AS g ON a.user_id = g.user_id AND g.challenge_id = ?
    WHERE a.start_date_local BETWEEN g.start_date AND g.end_date
    GROUP BY a.user_id, date
)
SELECT a.id, a.user_id, a.create_at, a.start_date, a.start_date_local, a.distance, a.average_speed, a.moving_time, a.name, a.sport_type, a.max_speed, a.original_data
FROM raw_activities AS a
 INNER JOIN max_distance_activities AS mda ON a.user_id = mda.user_id AND a.distance = mda.max_distance
`

func (q *Queries) GetLongestActivityPerDay(ctx context.Context, challengeID int64) ([]RawActivity, error) {
	rows, err := q.db.QueryContext(ctx, getLongestActivityPerDay, challengeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []RawActivity{}
	for rows.Next() {
		var i RawActivity
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.CreateAt,
			&i.StartDate,
			&i.StartDateLocal,
			&i.Distance,
			&i.AverageSpeed,
			&i.MovingTime,
			&i.Name,
			&i.SportType,
			&i.MaxSpeed,
			&i.OriginalData,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listGamers = `-- name: ListGamers :many
SELECT
    challenge_id, user_id, user_name, start_date, end_date, target
FROM gamers AS l
JOIN register_users AS r ON l.user_id = r.id AND active = 1
WHERE challenge_id = ?
`

type ListGamersRow struct {
	ChallengeID int64  `json:"challenge_id"`
	UserID      int64  `json:"user_id"`
	UserName    string `json:"user_name"`
	StartDate   int64  `json:"start_date"`
	EndDate     int64  `json:"end_date"`
	Target      int64  `json:"target"`
}

func (q *Queries) ListGamers(ctx context.Context, challengeID int64) ([]ListGamersRow, error) {
	rows, err := q.db.QueryContext(ctx, listGamers, challengeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListGamersRow{}
	for rows.Next() {
		var i ListGamersRow
		if err := rows.Scan(
			&i.ChallengeID,
			&i.UserID,
			&i.UserName,
			&i.StartDate,
			&i.EndDate,
			&i.Target,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
